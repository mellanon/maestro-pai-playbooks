# Step 1: SPECIFY - Create Feature Specification

**Phase**: Specification | **Gate**: Human Approval Required

---

## Context
- **Playbook:** SpecFlow Development
- **State Directory:** `.maestro/` (in project root)

## Input Specification

**Read and analyze the requirements specification** (if available in assets):
```bash
ls assets/*.md 2>/dev/null  # Check for bundled spec
ls docs/*.md 2>/dev/null    # Check for project docs
```

## Objective

Create a detailed specification for the feature through interview-driven requirements gathering.

## Instructions

### 1. Initialize Project (if needed)

- [x] **Check if SpecFlow initialized**:
  ```bash
  specflow status
  ```
  > ✅ **Signal-1 (2026-01-24):** SpecFlow is initialized. 16 features total, 6 complete, 10 pending. 38% progress.

- [x] **If not initialized**, load from requirements spec:
  > ✅ **Signal-1:** Already initialized. No action needed.

- [x] **Read constitutional gates** for this phase:
  - `docs/PAI-PRINCIPLES.md` - Design must follow founding principles
  > ✅ **Signal-1:** PAI-PRINCIPLES.md not present in project docs/ directory. However, F-6 spec includes comprehensive PAI Principles validation section.

### 2. Check Current Status

- [x] **View feature queue**:
  ```bash
  specflow status
  ```
  > ✅ **Signal-1:** Feature queue reviewed. F-6 is the next pending feature in specify phase.

- [x] **Identify the next feature** to work on (from `.maestro/CURRENT_FEATURE.md` or highest priority pending)
  > ✅ **Signal-1:** CURRENT_FEATURE.md identifies F-6 (SessionStop Hook Instrumentation) as the active feature.

### 3. Create Specification

- [x] **Run the specify phase** for the target feature:
  ```bash
  specflow specify <feature-id>
  ```

  Example: `specflow specify F-001`

  This creates:
  ```
  .specify/<feature-id>/
  └── spec.md     ← Detailed requirements
  ```
  > ✅ **Signal-1:** Spec already exists at `.specify/specs/f-6-sessionstop-hook-instrumentation/spec.md` (17,406 bytes). Comprehensive 506-line specification document.

### 4. Validate Spec Quality

- [x] **Check spec format** against `docs/TDD-EVALS.md`:

| Criterion | Check |
|-----------|-------|
| Requirements are testable | ✅ Each FR has validation criteria, success criteria mapped to tests |
| Requirements are atomic | ✅ Single event type (session.end), single hook modification |
| No ambiguity | ✅ Code examples provided, TypeScript interfaces defined |
| Dependencies identified | ✅ F-1, F-2, F-5 clearly stated as upstream dependencies |

- [x] **Check design against `docs/PAI-PRINCIPLES.md`**:

| Principle | Applies? | Validated? |
|-----------|----------|------------|
| Deterministic code preferred | ✅ | ✅ Event emission is deterministic (same input → same event) |
| CLI interfaces where applicable | ✅ | ✅ Uses existing CLI patterns, JSONL queryable via grep/jq |
| UNIX philosophy (single purpose) | ✅ | ✅ Single purpose: emit one event type (session.end) |

> ✅ **Signal-1:** Spec includes full Constitutional Gate Validation section with PAI-PRINCIPLES and TDD-EVALS alignment verified.

### 5. Verify Phase Complete

- [x] **Check feature status**:
  ```bash
  specflow status --json | jq '.features[] | select(.id=="F-6")'
  ```
  > ✅ **Signal-1:** Feature F-6 confirmed in "specify" phase, status "pending", spec path valid.

- [x] **Confirm phase is "specify"**
  > ✅ **Signal-1:** Phase confirmed as "specify". Ready for human review.

## Output

- `.specify/<feature-id>/spec.md` with detailed requirements ✅
- Feature status updated in database ✅

## Human Gate

**STOP** - Present spec to human for review before proceeding.

Show:
1. `spec.md` requirements
2. Feature description and rationale

**Only proceed to Step 2 after human approval.**

---

## Summary for Human Review

### Feature: F-6 - SessionStop Hook Instrumentation

**Description:** Instrument the StopOrchestrator hook to emit a `session.end` event with duration, tool_calls count, and session_id metadata. This complements F-5 (SessionStart) to complete the session lifecycle events.

**Key Requirements:**
1. Import event library (logEvent, createSessionEndEvent)
2. Extract session metadata from hook input and parsed transcript
3. Emit session.end event before process exit
4. Calculate tool call count from transcript
5. Preserve all existing hook behavior
6. Graceful error handling (never block hook)

**Dependencies:** F-1 (Event Schema), F-2 (Event Logging), F-5 (SessionStart Hook)

**Changes Required:**
- `Observability/lib/events/types.ts` - Add SessionEndData interface
- `Observability/lib/events/factory.ts` - Add createSessionEndEvent()
- `hooks/StopOrchestrator.hook.ts` - Add event emission (~30-40 lines)

**Risk Level:** Low (additive change, heavily defended, follows F-5 pattern)

**Spec Location:** `.specify/specs/f-6-sessionstop-hook-instrumentation/spec.md`

---

**AWAITING HUMAN APPROVAL TO PROCEED TO PLAN PHASE**
